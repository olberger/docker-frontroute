#!/usr/bin/env php
<?php

// get an env var's value
function env($name, $default = null)
{
    $ret = getenv($name);
    if ($ret === false) {
        $ret = $default;
    }
    return $ret;
}

// get the port definitions from the PORT env vars values
function getUrlsFromEnv($prefix, $name, & $urls)
{
    // use explicit port definition
    $port = env($name . '_port');
    if ($port !== null) {
        $url = env($prefix . '_PORT_' . $port . '_TCP');
        if ($url === null) {
            echo 'Error: Explicitly set port ' . $port . ' for ' . $prefix . ', but not TCP port exposed' . PHP_EOL;
            exit(1);
        }
        $urls[] = $url;
        return;
    }

    // check for preferred port definitions
    foreach (array(80, 8080, 8000, 443) as $port) {
        // check the URL for that port, as passed by docker link variables
        $best = env($prefix . '_PORT_' . $port . '_TCP');
        if ($best !== null) {
            $urls[] = $best;
            #return;
        }
    }
    if (count($urls) == 0) {
        // use first available port definition
        $url = env($prefix . '_PORT');

        if ($url !== null && $prefix !== 'SCRIPT') {
            $urls[] = $url;
        }
        else {
            // still no URL found
            echo 'Skip ' . $prefix . ' because it has no port defined' . PHP_EOL;
        }
    }

}

// collected server instances
$servers = array();

// fetch container links from the env variables
foreach ($_SERVER as $key => $value) {
    // each container has an env variable named contname_NAME
    if (substr($key, -5) === '_NAME') {
        $prefix = substr($key, 0, -5);

        $name = $value;
            
        $pos = strrpos($name, '/');
        if ($pos !== false) {
            $name = substr($name, $pos + 1);
        }

        // get ports definitions for this container
        $urls = array();
        getUrlsFromEnv($prefix, $name, $urls);

        $servers[$name]= array();
        foreach ($urls as $url) {

            // base path (sub-folder)
            $path = '/';

            $portpos = strrpos($url, ':');
            if ($portpos !== false) {
                $port = substr($url, $portpos + 1);
            }
            if ($port == "443") {
                $url = str_replace('tcp://', 'https://', $url) . $path;
            }
            else {
                $url = str_replace('tcp://', 'http://', $url) . $path;
            }
            $servers[$name][$port] = $url;
            
            echo '/' . $name . ' => ' . $url . PHP_EOL;
        }
    }
}

if (!$servers) {
    echo 'No servers found' . PHP_EOL;
    exit(1);
}


$config = '# automatically generated by /apply-from-env.php
';

if (($default = env('default', null)) !== null) {
    $config .= '
    # redirect default name
    location = / {
        return 301 ' . $default . ';
    }
';
}

foreach ($servers as $name => $urls) {
    foreach ($urls as $port => $url) {
        $config .= 'server {
    listen ' . $port ;
        if ($port == "443") {
            $config .= ' ssl';
        }
        $config .= ';
#    root /dev/null;

';

        if ($port == "443") {
            $config .= '
        ssl_certificate           /etc/ssl/certs/ssl-cert-snakeoil.pem;
        ssl_certificate_key       /etc/ssl/private/ssl-cert-snakeoil.key;
';
        }

        $config .= '

    # proxy for ' . $name . '
    location /' . $name . '/ {
        proxy_pass ' . $url . ';

        # rewrite redirect / location headers to match this subdir
        proxy_redirect default;
        proxy_redirect / $scheme://$http_host/' . $name . '/;

        proxy_set_header Host $http_host;
        proxy_set_header X-Forwarded-For $remote_addr;
    }

    # requests without trailing slash will be forwarded to include slash
    location = /' . $name . ' {
        return 301 $scheme://$http_host$uri/$is_args$args;
    }
}
';
    }
}


echo $config;

file_put_contents('/etc/nginx/sites-enabled/default', $config);

